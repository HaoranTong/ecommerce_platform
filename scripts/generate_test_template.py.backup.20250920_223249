#!/usr/bin/env python3#!/usr/bin/env python3

""""""

五层架构智能测试生成器 - 增强版 v2.0五层架构标准测试生成器



根据MASTER.md规范和testing-standards.md生成完整测试套件根据测试标准 (docs/standards/testing-standards.md) 生成完整测试套件

集成智能模型分析器，自动解析SQLAlchemy模型结构符合70%单元、20%集成、6%E2E、2%烟雾、2%专项的分层架构

符合70%单元、20%集成、6%E2E、2%烟雾、2%专项的分层架构

使用方法:

核心功能 [CHECK:DEV-009]:    python scripts/generate_test_template.py module_name [--type all|unit|integration|smoke|e2e|specialized]

1. AST+运行时双重模型分析    

2. 智能Factory Boy工厂生成示例:

3. 完整五层测试架构生成    python scripts/generate_test_template.py user_auth --type all

4. 自动验证和质量检查    python scripts/generate_test_template.py shopping_cart --type unit



使用方法:生成标准:

    python scripts/generate_test_template.py module_name [options]- Factory Boy数据工厂模式

    - pytest.ini配置要求  

示例:- 五层测试架构分布

    python scripts/generate_test_template.py user_auth --type all --validate- 标准化测试结构

    python scripts/generate_test_template.py shopping_cart --type unit --dry-run"""

    

参数说明:import sys

    --type TYPE        : 测试类型 (all|unit|integration|smoke|e2e|specialized)import os

    --validate        : 生成后自动验证测试文件import argparse

    --dry-run         : 仅分析模型，不生成文件from pathlib import Path

    --detailed        : 输出详细分析报告from datetime import datetime

    --force           : 强制覆盖existing filesfrom typing import Dict, List, Any, Optional, Tuple

    from dataclasses import dataclass

符合标准:import ast

- MASTER.md强制检查点规范 [CHECK:DEV-009] [CHECK:TEST-001]import inspect

- testing-standards.md五层架构import importlib.util

- Factory Boy数据工厂模式

- pytest.ini配置要求# 添加项目根目录到Python路径

"""project_root = Path(__file__).parent.parent

sys.path.insert(0, str(project_root))

import sys

import os

import argparse@dataclass

import astclass FieldInfo:

import inspect    """字段信息数据类"""

import importlib.util    name: str

import subprocess    column_type: str

import json    python_type: str

from pathlib import Path    nullable: bool

from datetime import datetime    primary_key: bool

from typing import Dict, List, Any, Optional, Tuple, Union    foreign_key: Optional[str]

from dataclasses import dataclass, field    unique: bool

    default: Any

# 添加项目根目录到Python路径    constraints: List[str]

project_root = Path(__file__).parent.parent    

sys.path.insert(0, str(project_root))    

@dataclass  

class RelationshipInfo:

@dataclass    """关系信息数据类"""

class FieldInfo:    name: str

    """字段信息数据类 - 完整字段元数据"""    related_model: str

    name: str    relationship_type: str  # one-to-one, one-to-many, many-to-many

    column_type: str    back_populates: Optional[str]

    python_type: str    cascade: Optional[str]

    nullable: bool    foreign_keys: List[str]

    primary_key: bool

    foreign_key: Optional[str]

    unique: bool@dataclass

    default: Anyclass ModelInfo:

    constraints: List[str] = field(default_factory=list)    """模型信息数据类"""

    max_length: Optional[int] = None    name: str

    index: bool = False    tablename: str

    server_default: Any = None    fields: List[FieldInfo]

        relationships: List[RelationshipInfo]

        mixins: List[str]

@dataclass      docstring: Optional[str]

class RelationshipInfo:    primary_keys: List[str]

    """关系信息数据类 - 完整关系元数据"""    unique_constraints: List[List[str]]

    name: str

    related_model: str

    relationship_type: str  # one-to-one, one-to-many, many-to-manyclass FiveLayerTestGenerator:

    back_populates: Optional[str]    """五层架构测试生成器 - 集成智能模型分析 [CHECK:DEV-009]"""

    cascade: Optional[str]    

    foreign_keys: List[str] = field(default_factory=list)    def __init__(self):

    secondary: Optional[str] = None        self.project_root = Path(__file__).parent.parent

    lazy: Optional[str] = None        self.test_distributions = {

            'unit': 0.70,      # 70% 单元测试

            'integration': 0.20, # 20% 集成测试  

@dataclass            'e2e': 0.06,       # 6% E2E测试

class ModelInfo:            'smoke': 0.02,     # 2% 烟雾测试

    """模型信息数据类 - 完整模型元数据"""            'specialized': 0.02 # 2% 专项测试

    name: str        }

    tablename: str        self.models_cache = {}

    fields: List[FieldInfo]    

    relationships: List[RelationshipInfo]    def analyze_module_models(self, module_name: str) -> Dict[str, ModelInfo]:

    mixins: List[str] = field(default_factory=list)        """智能分析模块中的所有数据模型 [CHECK:TEST-001]"""

    docstring: Optional[str] = None        if module_name in self.models_cache:

    primary_keys: List[str] = field(default_factory=list)            return self.models_cache[module_name]

    unique_constraints: List[List[str]] = field(default_factory=list)            

    indexes: List[str] = field(default_factory=list)        print(f"🔍 智能分析模块: {module_name}")

            

    @property        # 1. 定位模块文件

    def foreign_key_fields(self) -> List[FieldInfo]:        models_file = self.project_root / f"app/modules/{module_name}/models.py"

        """获取所有外键字段"""        if not models_file.exists():

        return [f for f in self.fields if f.foreign_key]            raise FileNotFoundError(f"模型文件不存在: {models_file}")

                

    @property        # 2. AST语法分析

    def unique_fields(self) -> List[FieldInfo]:        ast_models = self._analyze_ast(models_file)

        """获取所有唯一字段"""        print(f"📋 AST分析发现 {len(ast_models)} 个模型类")

        return [f for f in self.fields if f.unique]        

                # 3. 运行时分析（导入模块获取完整信息）

    @property        runtime_models = self._analyze_runtime(module_name)

    def required_fields(self) -> List[FieldInfo]:        print(f"🏃 运行时分析发现 {len(runtime_models)} 个模型类")

        """获取所有必填字段"""        

        return [f for f in self.fields if not f.nullable and not f.primary_key and f.default is None]        # 4. 合并分析结果

        merged_models = self._merge_analysis_results(ast_models, runtime_models)

        print(f"✅ 合并完成，共分析 {len(merged_models)} 个模型")

class IntelligentModelAnalyzer:        

    """智能模型分析器 - AST+运行时双重分析 [CHECK:TEST-001]"""        # 5. 缓存结果

            self.models_cache[module_name] = merged_models

    def __init__(self, project_root: Path):        return merged_models

        self.project_root = project_root        

        self.analysis_cache = {}    def _analyze_ast(self, models_file: Path) -> Dict[str, Dict]:

                """AST语法分析 - 获取源代码结构"""

    def analyze_module(self, module_name: str) -> Dict[str, ModelInfo]:        with open(models_file, 'r', encoding='utf-8') as f:

        """完整分析模块中的所有数据模型"""            content = f.read()

        if module_name in self.analysis_cache:            

            return self.analysis_cache[module_name]        tree = ast.parse(content)

                    models = {}

        print(f"🔍 智能分析模块: {module_name}")        

                for node in ast.walk(tree):

        # 1. 验证模块文件存在            if isinstance(node, ast.ClassDef):

        models_file = self.project_root / f"app/modules/{module_name}/models.py"                # 检查是否是SQLAlchemy模型类

        if not models_file.exists():                if self._is_sqlalchemy_model(node):

            raise FileNotFoundError(f"模型文件不存在: {models_file}")                    model_info = self._extract_model_info_from_ast(node)

                                models[node.name] = model_info

        # 2. AST语法分析 - 获取源代码结构                    

        print("📋 执行AST语法分析...")        return models

        ast_models = self._analyze_ast(models_file)        

        print(f"   发现 {len(ast_models)} 个模型类")    def _is_sqlalchemy_model(self, class_node: ast.ClassDef) -> bool:

                """检查类是否是SQLAlchemy模型"""

        # 3. 运行时分析 - 获取完整类信息        # 检查是否继承自Base或包含__tablename__

        print("🏃 执行运行时分析...")        for base in class_node.bases:

        runtime_models = self._analyze_runtime(module_name)            if isinstance(base, ast.Name) and base.id == 'Base':

        print(f"   分析 {len(runtime_models)} 个模型类")                return True

                        

        # 4. 合并和验证分析结果        # 检查是否有__tablename__属性

        print("🔗 合并分析结果...")        for item in class_node.body:

        merged_models = self._merge_analysis_results(ast_models, runtime_models)            if (isinstance(item, ast.Assign) and 

                        any(isinstance(target, ast.Name) and target.id == '__tablename__' 

        # 5. 验证分析完整性                    for target in item.targets)):

        self._validate_analysis_results(merged_models)                return True

                            

        # 6. 缓存结果        return False

        self.analysis_cache[module_name] = merged_models        

        print(f"✅ 模型分析完成，共 {len(merged_models)} 个模型")    def _extract_model_info_from_ast(self, class_node: ast.ClassDef) -> Dict:

                """从AST节点提取模型信息"""

        return merged_models        model_info = {

                    'name': class_node.name,

    def _analyze_ast(self, models_file: Path) -> Dict[str, Dict]:            'tablename': None,

        """AST语法分析 - 提取源代码结构信息"""            'fields': [],

        with open(models_file, 'r', encoding='utf-8') as f:            'relationships': [],

            content = f.read()            'mixins': [],

                        'docstring': ast.get_docstring(class_node)

        try:        }

            tree = ast.parse(content)        

        except SyntaxError as e:        # 提取基类(混入)

            raise SyntaxError(f"模型文件语法错误: {e}")        for base in class_node.bases:

                        if isinstance(base, ast.Name):

        models = {}                model_info['mixins'].append(base.id)

                        

        for node in ast.walk(tree):        # 分析类体内容

            if isinstance(node, ast.ClassDef):        for item in class_node.body:

                if self._is_sqlalchemy_model(node):            if isinstance(item, ast.Assign):

                    model_info = self._extract_model_info_from_ast(node)                self._analyze_assignment(item, model_info)

                    models[node.name] = model_info                

                            return model_info

        return models        

            def _analyze_assignment(self, assign_node: ast.Assign, model_info: Dict):

    def _is_sqlalchemy_model(self, class_node: ast.ClassDef) -> bool:        """分析赋值语句 - 提取字段和关系定义"""

        """检查类是否是SQLAlchemy模型"""        for target in assign_node.targets:

        # 检查继承关系 - 继承自Base            if isinstance(target, ast.Name):

        for base in class_node.bases:                attr_name = target.id

            if isinstance(base, ast.Name) and base.id == 'Base':                

                return True                if attr_name == '__tablename__':

                                    # 提取表名

        # 检查__tablename__属性存在                    if isinstance(assign_node.value, ast.Constant):

        for item in class_node.body:                        model_info['tablename'] = assign_node.value.value

            if (isinstance(item, ast.Assign) and                         

                any(isinstance(target, ast.Name) and target.id == '__tablename__'                 elif isinstance(assign_node.value, ast.Call):

                    for target in item.targets)):                    # 分析函数调用 - Column或relationship

                return True                    func_name = self._get_function_name(assign_node.value.func)

                                        

        return False                    if func_name == 'Column':

                                field_info = self._analyze_column_definition(attr_name, assign_node.value)

    def _extract_model_info_from_ast(self, class_node: ast.ClassDef) -> Dict:                        model_info['fields'].append(field_info)

        """从AST节点提取模型基础信息"""                        

        model_info = {                    elif func_name == 'relationship':

            'name': class_node.name,                        rel_info = self._analyze_relationship_definition(attr_name, assign_node.value)

            'tablename': None,                        model_info['relationships'].append(rel_info)

            'fields': [],                        

            'relationships': [],    def _get_function_name(self, func_node) -> str:

            'mixins': [],        """获取函数名称"""

            'docstring': ast.get_docstring(class_node),        if isinstance(func_node, ast.Name):

            'raw_fields': {},  # 原始字段定义，供后续分析使用            return func_node.id

            'raw_relationships': {}  # 原始关系定义        elif isinstance(func_node, ast.Attribute):

        }            return func_node.attr

                return ''

        # 提取基类信息        

        for base in class_node.bases:    def _analyze_column_definition(self, field_name: str, call_node: ast.Call) -> Dict:

            if isinstance(base, ast.Name):        """分析Column定义"""

                model_info['mixins'].append(base.id)        field_info = {

                    'name': field_name,

        # 分析类体 - 提取字段和关系定义            'column_type': None,

        for item in class_node.body:            'nullable': True,  # SQLAlchemy默认

            if isinstance(item, ast.Assign):            'primary_key': False,

                self._analyze_class_assignment(item, model_info)            'foreign_key': None,

                            'unique': False,

        return model_info            'default': None,

                    'constraints': []

    def _analyze_class_assignment(self, assign_node: ast.Assign, model_info: Dict):        }

        """分析类中的赋值语句"""        

        for target in assign_node.targets:        # 分析位置参数 - 通常第一个是类型

            if isinstance(target, ast.Name):        if call_node.args:

                attr_name = target.id            type_arg = call_node.args[0]

                            field_info['column_type'] = self._extract_column_type(type_arg)

                # 提取__tablename__            

                if attr_name == '__tablename__':        # 分析关键字参数

                    if isinstance(assign_node.value, ast.Constant):        for keyword in call_node.keywords:

                        model_info['tablename'] = assign_node.value.value            if keyword.arg == 'nullable':

                                        field_info['nullable'] = self._extract_boolean_value(keyword.value)

                # 分析函数调用 - Column 或 relationship            elif keyword.arg == 'primary_key':

                elif isinstance(assign_node.value, ast.Call):                field_info['primary_key'] = self._extract_boolean_value(keyword.value)

                    func_name = self._extract_function_name(assign_node.value.func)            elif keyword.arg == 'unique':

                                    field_info['unique'] = self._extract_boolean_value(keyword.value)

                    if func_name == 'Column':            elif keyword.arg == 'default':

                        field_info = self._analyze_column_from_ast(attr_name, assign_node.value)                field_info['default'] = self._extract_default_value(keyword.value)

                        model_info['fields'].append(field_info)                

                        model_info['raw_fields'][attr_name] = assign_node.value        return field_info

                                

                    elif func_name == 'relationship':    def _extract_column_type(self, type_node) -> str:

                        rel_info = self._analyze_relationship_from_ast(attr_name, assign_node.value)        """提取列类型"""

                        model_info['relationships'].append(rel_info)        if isinstance(type_node, ast.Name):

                        model_info['raw_relationships'][attr_name] = assign_node.value            return type_node.id

                                elif isinstance(type_node, ast.Call):

    def _extract_function_name(self, func_node) -> str:            return self._get_function_name(type_node.func)

        """提取函数调用名称"""        return 'Unknown'

        if isinstance(func_node, ast.Name):        

            return func_node.id    def _extract_boolean_value(self, value_node) -> bool:

        elif isinstance(func_node, ast.Attribute):        """提取布尔值"""

            return func_node.attr        if isinstance(value_node, ast.Constant):

        return 'Unknown'            return bool(value_node.value)

                elif isinstance(value_node, ast.NameConstant):  # Python < 3.8

    def _analyze_column_from_ast(self, field_name: str, call_node: ast.Call) -> Dict:            return bool(value_node.value)

        """从AST分析Column定义"""        return False

        field_info = {        

            'name': field_name,    def _extract_default_value(self, value_node) -> Any:

            'column_type': 'Unknown',        """提取默认值"""

            'nullable': True,  # SQLAlchemy默认值        if isinstance(value_node, ast.Constant):

            'primary_key': False,            return value_node.value

            'foreign_key': None,        elif isinstance(value_node, ast.NameConstant):  # Python < 3.8  

            'unique': False,            return value_node.value

            'default': None,        return None

            'index': False,        

            'constraints': [],    def _analyze_relationship_definition(self, rel_name: str, call_node: ast.Call) -> Dict:

            'max_length': None        """分析relationship定义"""

        }        rel_info = {

                    'name': rel_name,

        # 分析位置参数 - 第一个通常是类型            'related_model': None,

        if call_node.args:            'back_populates': None,

            type_arg = call_node.args[0]            'cascade': None

            field_info['column_type'] = self._extract_column_type_from_ast(type_arg)        }

                    

        # 分析关键字参数        # 分析位置参数 - 通常第一个是相关模型

        for keyword in call_node.keywords:        if call_node.args:

            arg_name = keyword.arg            model_arg = call_node.args[0]

            if arg_name == 'nullable':            if isinstance(model_arg, ast.Constant):

                field_info['nullable'] = self._extract_boolean_from_ast(keyword.value)                rel_info['related_model'] = model_arg.value

            elif arg_name == 'primary_key':                

                field_info['primary_key'] = self._extract_boolean_from_ast(keyword.value)        # 分析关键字参数

            elif arg_name == 'unique':        for keyword in call_node.keywords:

                field_info['unique'] = self._extract_boolean_from_ast(keyword.value)            if keyword.arg == 'back_populates':

            elif arg_name == 'index':                if isinstance(keyword.value, ast.Constant):

                field_info['index'] = self._extract_boolean_from_ast(keyword.value)                    rel_info['back_populates'] = keyword.value.value

            elif arg_name == 'default':            elif keyword.arg == 'cascade':

                field_info['default'] = self._extract_literal_value_from_ast(keyword.value)                if isinstance(keyword.value, ast.Constant):

                                    rel_info['cascade'] = keyword.value.value

        return field_info                    

                return rel_info

    def _extract_column_type_from_ast(self, type_node) -> str:        

        """从AST节点提取列类型"""    def _analyze_runtime(self, module_name: str) -> Dict[str, Any]:

        if isinstance(type_node, ast.Name):        """运行时分析 - 导入模块获取完整类信息"""

            return type_node.id        try:

        elif isinstance(type_node, ast.Call):            # 动态导入模块

            func_name = self._extract_function_name(type_node.func)            module_path = f"app.modules.{module_name}.models"

            # 处理带参数的类型，如String(50)            spec = importlib.util.spec_from_file_location(

            if func_name and type_node.args:                module_path, 

                if isinstance(type_node.args[0], ast.Constant):                self.project_root / f"app/modules/{module_name}/models.py"

                    return f"{func_name}({type_node.args[0].value})"            )

            return func_name            module = importlib.util.module_from_spec(spec)

        return 'Unknown'            spec.loader.exec_module(module)

                    

    def _extract_boolean_from_ast(self, value_node) -> bool:            models = {}

        """从AST节点提取布尔值"""            

        if isinstance(value_node, ast.Constant):            # 获取模块中的所有类

            return bool(value_node.value)            for name, obj in inspect.getmembers(module, inspect.isclass):

        elif hasattr(ast, 'NameConstant') and isinstance(value_node, ast.NameConstant):                if (hasattr(obj, '__tablename__') and 

            return bool(value_node.value)                    hasattr(obj, '__table__')):

        return False                    models[name] = self._extract_runtime_model_info(obj)

                            

    def _extract_literal_value_from_ast(self, value_node) -> Any:            return models

        """从AST节点提取字面值"""            

        if isinstance(value_node, ast.Constant):        except Exception as e:

            return value_node.value            print(f"⚠️ 运行时分析失败: {e}")

        elif hasattr(ast, 'NameConstant') and isinstance(value_node, ast.NameConstant):            return {}

            return value_node.value            

        elif isinstance(value_node, ast.Str):  # Python < 3.8 compatibility    def _extract_runtime_model_info(self, model_class) -> Dict:

            return value_node.s        """从运行时模型类提取信息"""

        elif isinstance(value_node, ast.Num):  # Python < 3.8 compatibility        table = model_class.__table__

            return value_node.n        

        return None        model_info = {

                    'name': model_class.__name__,

    def _analyze_relationship_from_ast(self, rel_name: str, call_node: ast.Call) -> Dict:            'tablename': table.name,

        """从AST分析relationship定义"""            'fields': [],

        rel_info = {            'relationships': [],

            'name': rel_name,            'primary_keys': [col.name for col in table.primary_key.columns],

            'related_model': None,            'unique_constraints': []

            'back_populates': None,        }

            'cascade': None,        

            'secondary': None,        # 分析字段

            'lazy': None        for column in table.columns:

        }            field_info = FieldInfo(

                        name=column.name,

        # 分析位置参数 - 第一个是相关模型                column_type=str(column.type),

        if call_node.args:                python_type=column.type.python_type.__name__ if hasattr(column.type, 'python_type') else 'str',

            model_arg = call_node.args[0]                nullable=column.nullable,

            if isinstance(model_arg, ast.Constant):                primary_key=column.primary_key,

                rel_info['related_model'] = model_arg.value                foreign_key=str(list(column.foreign_keys)[0].target_fullname) if column.foreign_keys else None,

                                unique=column.unique,

        # 分析关键字参数                default=column.default.arg if column.default else None,

        for keyword in call_node.keywords:                constraints=[]

            arg_name = keyword.arg            )

            if arg_name == 'back_populates':            model_info['fields'].append(field_info)

                rel_info['back_populates'] = self._extract_literal_value_from_ast(keyword.value)            

            elif arg_name == 'cascade':        # 分析关系

                rel_info['cascade'] = self._extract_literal_value_from_ast(keyword.value)        if hasattr(model_class, '__mapper__'):

            elif arg_name == 'secondary':            for rel_name, relationship in model_class.__mapper__.relationships.items():

                rel_info['secondary'] = self._extract_literal_value_from_ast(keyword.value)                rel_info = RelationshipInfo(

            elif arg_name == 'lazy':                    name=rel_name,

                rel_info['lazy'] = self._extract_literal_value_from_ast(keyword.value)                    related_model=relationship.mapper.class_.__name__,

                                    relationship_type=self._determine_relationship_type(relationship),

        return rel_info                    back_populates=relationship.back_populates,

                            cascade=str(relationship.cascade) if relationship.cascade else None,

    def _analyze_runtime(self, module_name: str) -> Dict[str, Dict]:                    foreign_keys=[str(fk.parent.name) for fk in relationship.foreign_keys]

        """运行时分析 - 导入模块获取完整类型信息"""                )

        try:                model_info['relationships'].append(rel_info)

            # 动态导入模块                

            module_path = f"app.modules.{module_name}.models"        return model_info

            models_file = self.project_root / f"app/modules/{module_name}/models.py"        

                def _determine_relationship_type(self, relationship) -> str:

            spec = importlib.util.spec_from_file_location(module_path, models_file)        """确定关系类型"""

            if spec is None:        if relationship.uselist:

                raise ImportError(f"无法加载模块规范: {module_path}")            return "one-to-many" if not relationship.secondary else "many-to-many"

                        else:

            module = importlib.util.module_from_spec(spec)            return "one-to-one"

                        

            # 执行模块以获取完整信息    def _merge_analysis_results(self, ast_models: Dict, runtime_models: Dict) -> Dict[str, ModelInfo]:

            spec.loader.exec_module(module)        """合并AST和运行时分析结果"""

                    merged = {}

            models = {}        

                    # 以运行时分析为准，AST分析补充

            # 获取所有SQLAlchemy模型类        for model_name, runtime_info in runtime_models.items():

            for name, obj in inspect.getmembers(module, inspect.isclass):            ast_info = ast_models.get(model_name, {})

                if (hasattr(obj, '__tablename__') and             

                    hasattr(obj, '__table__')):            merged[model_name] = ModelInfo(

                    models[name] = self._extract_runtime_model_info(obj)                name=model_name,

                                    tablename=runtime_info['tablename'],

            return models                fields=runtime_info['fields'],

                            relationships=runtime_info['relationships'],

        except Exception as e:                mixins=ast_info.get('mixins', []),

            print(f"⚠️ 运行时分析失败: {e}")                docstring=ast_info.get('docstring'),

            return {}                primary_keys=runtime_info.get('primary_keys', []),

                            unique_constraints=runtime_info.get('unique_constraints', [])

    def _extract_runtime_model_info(self, model_class) -> Dict:            )

        """从运行时模型类提取完整信息"""            

        table = model_class.__table__        return merged

                    return {}

        model_info = {            

            'name': model_class.__name__,        # 2. 运行时分析（导入模块获取完整信息）

            'tablename': table.name,        models = self._analyze_runtime_models(module_name)

            'fields': [],        print(f"✅ 发现 {len(models)} 个数据模型")

            'relationships': [],        

            'primary_keys': [col.name for col in table.primary_key.columns],        # 缓存结果

            'unique_constraints': [],        self.models_cache[module_name] = models

            'indexes': [idx.name for idx in table.indexes] if hasattr(table, 'indexes') else []        return models

        }        

            def _analyze_runtime_models(self, module_name: str) -> Dict[str, ModelInfo]:

        # 分析表字段        """运行时分析 - 导入模块获取完整类信息"""

        for column in table.columns:        try:

            field_info = FieldInfo(            # 动态导入模块

                name=column.name,            module_path = f"app.modules.{module_name}.models"

                column_type=str(column.type),            spec = importlib.util.spec_from_file_location(

                python_type=self._get_python_type_from_column(column),                module_path, 

                nullable=column.nullable,                self.project_root / f"app/modules/{module_name}/models.py"

                primary_key=column.primary_key,            )

                foreign_key=self._extract_foreign_key_info(column),            module = importlib.util.module_from_spec(spec)

                unique=column.unique or False,            spec.loader.exec_module(module)

                default=self._extract_column_default(column),            

                index=column.index or False,            models = {}

                max_length=self._extract_column_max_length(column),            

                server_default=self._extract_server_default(column)            # 获取模块中的所有SQLAlchemy模型类

            )            for name, obj in inspect.getmembers(module, inspect.isclass):

            model_info['fields'].append(field_info)                if (hasattr(obj, '__tablename__') and 

                                hasattr(obj, '__table__') and

        # 分析表关系                    obj.__module__ == module_path):  # 确保是当前模块定义的类

        if hasattr(model_class, '__mapper__'):                    model_info = self._extract_model_info(obj)

            for rel_name, relationship in model_class.__mapper__.relationships.items():                    models[name] = model_info

                rel_info = RelationshipInfo(                    print(f"  📋 {name}: {len(model_info.fields)}字段, {len(model_info.relationships)}关系")

                    name=rel_name,                    

                    related_model=relationship.mapper.class_.__name__,            return models

                    relationship_type=self._determine_relationship_type(relationship),            

                    back_populates=relationship.back_populates,        except Exception as e:

                    cascade=str(relationship.cascade) if relationship.cascade else None,            print(f"❌ 模型分析失败: {e}")

                    foreign_keys=[fk.parent.name for fk in relationship.foreign_keys],            return {}

                    secondary=relationship.secondary.name if relationship.secondary is not None else None,            

                    lazy=str(relationship.lazy) if relationship.lazy else None    def _extract_model_info(self, model_class) -> ModelInfo:

                )        """从SQLAlchemy模型类提取完整信息"""

                model_info['relationships'].append(rel_info)        table = model_class.__table__

                

        # 分析唯一约束        # 基础信息

        for constraint in table.constraints:        model_info = ModelInfo(

            if hasattr(constraint, 'columns') and len(constraint.columns) > 1:            name=model_class.__name__,

                if constraint.__class__.__name__ == 'UniqueConstraint':            tablename=table.name,

                    model_info['unique_constraints'].append([col.name for col in constraint.columns])            fields=[],

                                relationships=[],

        return model_info            mixins=self._extract_mixins(model_class),

                    docstring=inspect.getdoc(model_class),

    def _get_python_type_from_column(self, column) -> str:            primary_keys=[col.name for col in table.primary_key.columns],

        """获取列对应的Python类型"""            unique_constraints=[]

        try:        )

            if hasattr(column.type, 'python_type'):        

                return column.type.python_type.__name__        # 分析字段

            else:        for column in table.columns:

                # 根据SQLAlchemy类型推断Python类型            field_info = FieldInfo(

                type_str = str(column.type).lower()                name=column.name,

                if 'int' in type_str:                column_type=str(column.type),

                    return 'int'                python_type=self._get_python_type(column.type),

                elif 'float' in type_str or 'decimal' in type_str or 'numeric' in type_str:                nullable=column.nullable,

                    return 'float'                primary_key=column.primary_key,

                elif 'bool' in type_str:                foreign_key=str(list(column.foreign_keys)[0].target_fullname) if column.foreign_keys else None,

                    return 'bool'                unique=column.unique,

                elif 'date' in type_str:                default=column.default.arg if column.default else None,

                    return 'datetime'                constraints=self._extract_constraints(column)

                else:            )

                    return 'str'            model_info.fields.append(field_info)

        except:            

            return 'str'        # 分析关系

                    if hasattr(model_class, '__mapper__'):

    def _extract_foreign_key_info(self, column) -> Optional[str]:            for rel_name, relationship in model_class.__mapper__.relationships.items():

        """提取外键信息"""                rel_info = RelationshipInfo(

        if column.foreign_keys:                    name=rel_name,

            fk = list(column.foreign_keys)[0]                    related_model=relationship.mapper.class_.__name__,

            return str(fk.target_fullname)                    relationship_type=self._determine_relationship_type(relationship),

        return None                    back_populates=relationship.back_populates,

                            cascade=str(relationship.cascade) if relationship.cascade else None,

    def _extract_column_default(self, column) -> Any:                    foreign_keys=[str(fk.parent.name) for fk in relationship.foreign_keys]

        """提取列默认值"""                )

        if column.default is not None:                model_info.relationships.append(rel_info)

            if hasattr(column.default, 'arg'):                

                return column.default.arg        return model_info

            elif hasattr(column.default, 'is_scalar') and column.default.is_scalar:        

                return column.default.arg    def _extract_mixins(self, model_class) -> List[str]:

        return None        """提取模型继承的混入类"""

                mixins = []

    def _extract_server_default(self, column) -> Any:        for base in model_class.__mro__:

        """提取服务器端默认值"""            if (base.__name__ not in ['object', 'Base', model_class.__name__] and 

        if column.server_default is not None:                'Mixin' in base.__name__):

            if hasattr(column.server_default, 'arg'):                mixins.append(base.__name__)

                return str(column.server_default.arg)        return mixins

        return None        

            def _get_python_type(self, column_type) -> str:

    def _extract_column_max_length(self, column) -> Optional[int]:        """获取列类型对应的Python类型"""

        """提取列最大长度"""        try:

        try:            return column_type.python_type.__name__

            if hasattr(column.type, 'length') and column.type.length:        except:

                return column.type.length            return 'str'  # 默认字符串类型

        except:            

            pass    def _extract_constraints(self, column) -> List[str]:

        return None        """提取列约束信息"""

                constraints = []

    def _determine_relationship_type(self, relationship) -> str:        if column.primary_key:

        """确定关系类型"""            constraints.append('PRIMARY KEY')

        if relationship.secondary is not None:        if not column.nullable:

            return "many-to-many"            constraints.append('NOT NULL')

        elif relationship.uselist:        if column.unique:

            return "one-to-many"            constraints.append('UNIQUE')

        else:        if column.foreign_keys:

            return "one-to-one"            constraints.append('FOREIGN KEY')

                    return constraints

    def _merge_analysis_results(self, ast_models: Dict, runtime_models: Dict) -> Dict[str, ModelInfo]:        

        """合并AST和运行时分析结果"""    def _determine_relationship_type(self, relationship) -> str:

        merged = {}        """确定关系类型"""

                if relationship.uselist:

        # 以运行时分析为准，AST分析提供补充信息            return "one-to-many" if not hasattr(relationship, 'secondary') or relationship.secondary is None else "many-to-many"

        for model_name, runtime_info in runtime_models.items():        else:

            ast_info = ast_models.get(model_name, {})            return "one-to-one"

                

            # 创建完整的ModelInfo对象    def generate_unit_tests(self, module_name: str) -> Dict[str, str]:

            merged[model_name] = ModelInfo(        """生成单元测试 (70% - Mock + SQLite内存)"""

                name=model_name,        

                tablename=runtime_info['tablename'],        # Mock模型测试 (test_models/)

                fields=runtime_info['fields'],        mock_tests = self._generate_mock_model_tests(module_name)

                relationships=runtime_info['relationships'],        

                mixins=ast_info.get('mixins', []),        # 服务层测试 (test_services/) 

                docstring=ast_info.get('docstring'),        service_tests = self._generate_service_tests(module_name)

                primary_keys=runtime_info.get('primary_keys', []),        

                unique_constraints=runtime_info.get('unique_constraints', []),        # 独立业务流程测试 (*_standalone.py)

                indexes=runtime_info.get('indexes', [])        standalone_tests = self._generate_standalone_tests(module_name)

            )        

                    return {

        return merged            f'tests/unit/test_models/test_{module_name}_models.py': mock_tests,

                    f'tests/unit/test_services/test_{module_name}_service.py': service_tests, 

    def _validate_analysis_results(self, models: Dict[str, ModelInfo]):            f'tests/unit/test_{module_name}_standalone.py': standalone_tests

        """验证分析结果的完整性和准确性"""        }

        for model_name, model in models.items():    

            # 验证基本信息    def _generate_mock_model_tests(self, module_name: str) -> str:

            if not model.tablename:        """生成Mock模型测试 - 基于智能分析，为每个模型生成测试类"""

                print(f"⚠️ 模型 {model_name} 缺少表名")        

                        # 分析模块中的所有模型

            if not model.fields:        models = self.analyze_module_models(module_name)

                print(f"⚠️ 模型 {model_name} 没有字段定义")        

                        if not models:

            # 验证主键            return self._generate_fallback_mock_tests(module_name)

            pk_fields = [f for f in model.fields if f.primary_key]            

            if not pk_fields and not model.primary_keys:        # 生成文件头部

                print(f"⚠️ 模型 {model_name} 没有主键定义")        imports = [

                            f"from app.modules.{module_name}.models import {', '.join(models.keys())}",

            # 验证外键引用        ]

            for field in model.foreign_key_fields:        

                if field.foreign_key:        test_classes = []

                    referenced_table = field.foreign_key.split('.')[0]        

                    print(f"🔗 {model_name}.{field.name} -> {field.foreign_key}")        # 为每个模型生成测试类

                            for model_name, model_info in models.items():

    def generate_analysis_report(self, models: Dict[str, ModelInfo]) -> str:            test_class = self._generate_model_test_class(model_name, model_info, module_name)

        """生成详细的模型分析报告"""            test_classes.append(test_class)

        report_lines = []            

        report_lines.append("# 智能模型分析报告")        return f'''"""

        report_lines.append(f"**生成时间**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"){module_name.title()} 模型智能测试套件

        report_lines.append(f"**分析模型数量**: {len(models)}")

        report_lines.append("")测试类型: 单元测试 (Mock + 智能分析)

        数据策略: 100% Mock对象，无数据库依赖

        # 统计信息生成时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

        total_fields = sum(len(model.fields) for model in models.values())模型数量: {len(models)}

        total_relationships = sum(len(model.relationships) for model in models.values())

        total_foreign_keys = sum(len(model.foreign_key_fields) for model in models.values())根据testing-standards.md第32-45行Mock测试规范

        基于智能模型分析自动生成

        report_lines.append("## 📊 统计概览")"""

        report_lines.append(f"- **总字段数**: {total_fields}")

        report_lines.append(f"- **总关系数**: {total_relationships}")import pytest

        report_lines.append(f"- **外键字段**: {total_foreign_keys}")from unittest.mock import Mock, patch, MagicMock

        report_lines.append("")from datetime import datetime, date

        from decimal import Decimal

        # 详细模型信息

        for model_name, model in models.items():# 测试工厂导入 - Factory Boy模式  

            report_lines.append(f"## 🏗️ {model_name} 模型")from tests.factories import StandardTestDataFactory, TestDataValidator

            report_lines.append(f"- **表名**: `{model.tablename}`")

            report_lines.append(f"- **字段数**: {len(model.fields)}")# 模型导入

            report_lines.append(f"- **关系数**: {len(model.relationships)}"){chr(10).join(imports)}

            report_lines.append(f"- **混入**: {', '.join(model.mixins) if model.mixins else '无'}")

            

            if model.docstring:{chr(10).join(test_classes)}

                report_lines.append(f"- **说明**: {model.docstring.split('.')[0]}...")'''

            

            # 字段详情    def _generate_model_test_class(self, model_name: str, model_info: ModelInfo, module_name: str) -> str:

            report_lines.append("### 📝 字段详情")        """为单个模型生成测试类"""

            for field in model.fields:        

                constraints = []        # 生成字段测试

                if field.primary_key:        field_tests = []

                    constraints.append("主键")        for field in model_info.fields:

                if not field.nullable:            field_test = self._generate_field_test(field, model_name)

                    constraints.append("必填")            if field_test:

                if field.unique:                field_tests.append(field_test)

                    constraints.append("唯一")                

                if field.foreign_key:        # 生成关系测试

                    constraints.append(f"外键→{field.foreign_key}")        relationship_tests = []

                if field.index:        for rel in model_info.relationships:

                    constraints.append("索引")            rel_test = self._generate_relationship_test(rel, model_name)

                                if rel_test:

                constraint_text = f" [{', '.join(constraints)}]" if constraints else ""                relationship_tests.append(rel_test)

                default_text = f" (默认: {field.default})" if field.default is not None else ""        

                        return f'''

                report_lines.append(f"- **{field.name}**: {field.column_type}{constraint_text}{default_text}")class Test{model_name}Model:

                    """智能生成的{model_name}模型测试"""

            # 关系详情    

            if model.relationships:    def setup_method(self):

                report_lines.append("### 🔗 关系详情")        """测试准备"""

                for rel in model.relationships:        self.mock_{model_name.lower()} = Mock()

                    cascade_text = f" (级联: {rel.cascade})" if rel.cascade else ""        self.test_data = StandardTestDataFactory.create_{model_name.lower()}_data()

                    report_lines.append(f"- **{rel.name}**: {rel.relationship_type} → {rel.related_model}{cascade_text}")        

                        def test_{model_name.lower()}_model_structure(self):

            report_lines.append("")        """测试{model_name}模型结构"""

                    # 验证表名

        return "\n".join(report_lines)        assert {model_name}.__tablename__ == '{model_info.tablename}'

        

        # 验证主键字段

def main():        primary_keys = {model_info.primary_keys}

    """主函数 - 解析参数并执行测试生成"""        assert len(primary_keys) > 0, "模型必须有主键"

    parser = argparse.ArgumentParser(        

        description='五层架构智能测试生成器 v2.0',    def test_{model_name.lower()}_model_fields(self):

        formatter_class=argparse.RawDescriptionHelpFormatter,        """测试{model_name}模型字段定义"""

        epilog="""        # 验证所有字段存在

示例:        expected_fields = {[f"'{field.name}'" for field in model_info.fields]}

  python scripts/generate_test_template.py user_auth --type all --validate        for field_name in expected_fields:

  python scripts/generate_test_template.py shopping_cart --type unit --dry-run            assert hasattr({model_name}, field_name), f"字段 {{field_name}} 不存在"

  python scripts/generate_test_template.py payment_service --detailed            

        """{chr(10).join(field_tests)}

    )

    {chr(10).join(relationship_tests)}

    parser.add_argument('module_name', 

                       help='要分析和生成测试的模块名称')    def test_{model_name.lower()}_repr(self, mocker):

    parser.add_argument('--type',         """测试{model_name}模型字符串表示"""

                       choices=['all', 'unit', 'integration', 'smoke', 'e2e', 'specialized'],        mock_instance = mocker.Mock(spec={model_name})

                       default='all',        mock_instance.id = 1

                       help='要生成的测试类型 (默认: all)')        {self._generate_repr_setup(model_info)}

    parser.add_argument('--validate',         

                       action='store_true',        # 模拟__repr__方法

                       help='生成后自动验证测试文件')        result = f"<{model_name}(id={{mock_instance.id}})>"

    parser.add_argument('--dry-run',        assert result is not None

                       action='store_true', '''

                       help='仅分析模型，不生成文件')

    parser.add_argument('--detailed',    def _generate_field_test(self, field: FieldInfo, model_name: str) -> str:

                       action='store_true',        """生成字段测试方法"""

                       help='输出详细分析报告')        

    parser.add_argument('--force',        test_cases = []

                       action='store_true',        

                       help='强制覆盖existing files')        # 主键测试

            if field.primary_key:

    args = parser.parse_args()            test_cases.append(f"        # {field.name}是主键")

                test_cases.append(f"        assert {model_name}.__table__.columns['{field.name}'].primary_key")

    try:            

        # 创建智能分析器        # 非空约束测试

        analyzer = IntelligentModelAnalyzer(project_root)        if not field.nullable:

                    test_cases.append(f"        # {field.name}不能为空")

        # 分析模块            test_cases.append(f"        assert not {model_name}.__table__.columns['{field.name}'].nullable")

        models = analyzer.analyze_module(args.module_name)            

                # 唯一约束测试  

        if not models:        if field.unique:

            print(f"❌ 模块 {args.module_name} 中没有发现任何模型")            test_cases.append(f"        # {field.name}必须唯一")

            return 1            test_cases.append(f"        assert {model_name}.__table__.columns['{field.name}'].unique")

                        

        # 输出详细报告        # 外键测试

        if args.detailed or args.dry_run:        if field.foreign_key:

            report = analyzer.generate_analysis_report(models)            test_cases.append(f"        # {field.name}是外键")

            print("\n" + report)            test_cases.append(f"        assert len({model_name}.__table__.columns['{field.name}'].foreign_keys) > 0")

                        

        if args.dry_run:        if not test_cases:

            print("🔍 干运行模式完成")            return ""

            return 0            

                    return f'''

        # TODO: 在后续任务中实现完整的测试生成功能    def test_{field.name}_field_constraints(self):

        print("🚧 完整测试生成功能将在下一个TODO任务中实现")        """测试{field.name}字段约束"""

        print("✅ 任务2完成：智能模型分析器已成功整合"){chr(10).join(test_cases)}'''

        

        return 0    def _generate_relationship_test(self, rel: RelationshipInfo, model_name: str) -> str:

                """生成关系测试方法"""

    except Exception as e:        return f'''

        print(f"❌ 执行失败: {e}")    def test_{rel.name}_relationship(self):

        return 1        """测试{rel.name}关系定义"""

        # 验证关系存在

        assert hasattr({model_name}, '{rel.name}')

if __name__ == "__main__":        

    sys.exit(main())        # 验证关系类型: {rel.relationship_type}
        relationship = {model_name}.__mapper__.relationships['{rel.name}']
        assert relationship is not None'''

    def _generate_repr_setup(self, model_info: ModelInfo) -> str:
        """生成repr测试的数据设置"""
        setup_lines = []
        for field in model_info.fields[:3]:  # 只取前3个字段作为示例
            if field.name != 'id':
                if field.python_type == 'str':
                    setup_lines.append(f"        mock_instance.{field.name} = 'test_{field.name}'")
                elif field.python_type in ['int', 'Integer']:
                    setup_lines.append(f"        mock_instance.{field.name} = 123")
                elif field.python_type == 'bool':
                    setup_lines.append(f"        mock_instance.{field.name} = True")
        return "\n".join(setup_lines)
        
    def _generate_fallback_mock_tests(self, module_name: str) -> str:
        """当智能分析失败时的备用生成方案"""
        return f'''"""
{module_name.title()} 模型Mock测试套件 (备用方案)

测试类型: 单元测试 (Mock)
数据策略: 100% Mock对象，无数据库依赖
生成时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

注意: 智能分析失败，使用备用模板
"""

import pytest
from unittest.mock import Mock, patch, MagicMock
from datetime import datetime, date

# 测试工厂导入 - Factory Boy模式
from tests.factories import StandardTestDataFactory


class TestMock{module_name.title()}Model:
    """Mock {module_name} 模型测试 (备用)"""
    
    def setup_method(self):
        """每个测试方法前的准备"""
        self.mock_{module_name} = Mock()
        
    def test_model_validation_with_valid_data(self, mocker):
        """测试模型验证 - 有效数据"""
        # 使用Factory Boy创建Mock数据
        mock_data = StandardTestDataFactory.create_generic_data()
        mock_validator = mocker.Mock()
        mock_validator.validate.return_value = True
        
        # 执行验证
        result = mock_validator.validate(mock_data)
        
        # 验证调用
        assert result is True
        mock_validator.validate.assert_called_once_with(mock_data)
'''
        
        # 验证调用
        assert result is True
        mock_validator.validate.assert_called_once_with(mock_data)
        
    def test_model_validation_with_invalid_data(self, mocker):
        """测试模型验证 - 无效数据"""
        mock_validator = mocker.Mock()
        mock_validator.validate.side_effect = ValueError("Validation failed")
        
        # 验证异常抛出
        with pytest.raises(ValueError, match="Validation failed"):
            mock_validator.validate({{"invalid": "data"}})
            
    @pytest.mark.parametrize("field_name,field_value,expected", [
        ("status", "active", True),
        ("status", "inactive", False), 
        ("status", None, False),
    ])
    def test_status_field_validation(self, field_name, field_value, expected, mocker):
        """参数化测试状态字段验证"""
        mock_model = mocker.Mock()
        mock_model.status = field_value
        
        # Mock验证逻辑
        result = field_value == "active" if field_value else False
        assert result == expected
'''
    
    def _generate_service_tests(self, module_name: str) -> str:
        """生成服务层测试 - SQLite内存数据库"""
        return f'''"""
{module_name.title()} 服务层测试套件

测试类型: 单元测试 (Service)
数据策略: SQLite内存数据库, unit_test_db fixture
生成时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

根据testing-standards.md第54-68行服务测试规范
"""

import pytest
from sqlalchemy.orm import Session

# 测试工厂导入
from tests.factories import {module_name.title()}Factory, UserFactory

# Fixture导入
from tests.conftest import unit_test_db

# 被测模块导入
from app.modules.{module_name}.service import {module_name.title()}Service
from app.modules.{module_name}.models import {module_name.title()}


class Test{module_name.title()}Service:
    """服务层业务逻辑测试"""
    
    def setup_method(self):
        """测试准备"""
        self.test_data = {module_name.title()}Factory.build_dict()
        
    def test_create_{module_name}_with_valid_data(self, unit_test_db: Session):
        """测试创建{module_name} - 有效数据"""
        # Arrange
        service = {module_name.title()}Service(unit_test_db)
        create_data = self.test_data
        
        # Act
        created_{module_name} = service.create(create_data)
        
        # Assert
        assert created_{module_name} is not None
        assert created_{module_name}.id is not None
        assert hasattr(created_{module_name}, 'created_at')
        
        # 验证数据库存储
        db_{module_name} = unit_test_db.query({module_name.title()}).filter_by(
            id=created_{module_name}.id
        ).first()
        assert db_{module_name} is not None
        
    def test_get_{module_name}_by_id_exists(self, unit_test_db: Session):
        """测试按ID查询{module_name} - 存在"""
        # 准备测试数据
        {module_name}_data = {module_name.title()}Factory.create_dict()
        service = {module_name.title()}Service(unit_test_db)
        created = service.create({module_name}_data)
        
        # 执行查询
        found_{module_name} = service.get_by_id(created.id)
        
        # 验证结果
        assert found_{module_name} is not None
        assert found_{module_name}.id == created.id
        
    def test_get_{module_name}_by_id_not_exists(self, unit_test_db: Session):
        """测试按ID查询{module_name} - 不存在"""
        service = {module_name.title()}Service(unit_test_db)
        
        # 查询不存在的ID
        result = service.get_by_id(99999)
        
        # 验证返回None
        assert result is None
        
    def test_update_{module_name}_success(self, unit_test_db: Session):
        """测试更新{module_name} - 成功"""
        # 创建测试数据
        service = {module_name.title()}Service(unit_test_db)
        created = service.create(self.test_data)
        
        # 准备更新数据
        update_data = {{"status": "updated"}}
        
        # 执行更新
        updated = service.update(created.id, update_data)
        
        # 验证更新结果
        assert updated is not None
        assert updated.status == "updated"
        assert hasattr(updated, 'updated_at')
        
    def test_delete_{module_name}_success(self, unit_test_db: Session):
        """测试删除{module_name} - 成功"""
        # 创建测试数据
        service = {module_name.title()}Service(unit_test_db)
        created = service.create(self.test_data)
        
        # 执行删除
        result = service.delete(created.id)
        
        # 验证删除结果
        assert result is True
        
        # 验证数据库中已删除
        deleted = service.get_by_id(created.id)
        assert deleted is None
'''

    def _generate_standalone_tests(self, module_name: str) -> str:
        """生成独立业务流程测试 - SQLite内存数据库"""
        return f'''"""
{module_name.title()} 独立业务流程测试套件

测试类型: 单元测试 (Standalone Business Flow)
数据策略: SQLite内存数据库, unit_test_db fixture
生成时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

根据testing-standards.md第78-92行业务流程测试规范
"""

import pytest
from sqlalchemy.orm import Session

# 测试工厂导入
from tests.factories import {module_name.title()}Factory, UserFactory

# Fixture导入  
from tests.conftest import unit_test_db

# 被测模块导入
from app.modules.{module_name}.service import {module_name.title()}Service
from app.modules.{module_name}.models import {module_name.title()}


class Test{module_name.title()}BusinessFlow:
    """独立业务流程测试"""
    
    def setup_method(self):
        """测试准备"""
        self.user_data = UserFactory.build_dict()
        self.{module_name}_data = {module_name.title()}Factory.build_dict()
        
    def test_complete_{module_name}_workflow(self, unit_test_db: Session):
        """测试完整{module_name}业务流程"""
        service = {module_name.title()}Service(unit_test_db)
        
        # 步骤1: 创建{module_name}
        created = service.create(self.{module_name}_data)
        assert created is not None
        assert created.id is not None
        
        # 步骤2: 查询验证
        found = service.get_by_id(created.id)
        assert found is not None
        assert found.id == created.id
        
        # 步骤3: 更新状态
        update_result = service.update(created.id, {{"status": "processed"}})
        assert update_result.status == "processed"
        
        # 步骤4: 最终验证
        final_check = service.get_by_id(created.id)
        assert final_check.status == "processed"
        
    def test_{module_name}_error_handling_flow(self, unit_test_db: Session):
        """测试{module_name}错误处理流程"""
        service = {module_name.title()}Service(unit_test_db)
        
        # 测试无效数据处理
        with pytest.raises((ValueError, TypeError)):
            service.create({{"invalid": "data"}})
            
        # 测试不存在ID处理
        result = service.get_by_id(99999)
        assert result is None
        
        # 测试删除不存在项目
        delete_result = service.delete(99999)
        assert delete_result is False
        
    @pytest.mark.parametrize("test_scenario,expected_result", [
        ("valid_create", True),
        ("valid_update", True),
        ("valid_delete", True),
    ])
    def test_{module_name}_scenarios(self, test_scenario, expected_result, unit_test_db: Session):
        """参数化测试{module_name}场景"""
        service = {module_name.title()}Service(unit_test_db)
        
        if test_scenario == "valid_create":
            result = service.create(self.{module_name}_data)
            assert (result is not None) == expected_result
            
        elif test_scenario == "valid_update":
            created = service.create(self.{module_name}_data)
            result = service.update(created.id, {{"status": "updated"}})
            assert (result is not None) == expected_result
            
        elif test_scenario == "valid_delete":
            created = service.create(self.{module_name}_data)
            result = service.delete(created.id)
            assert result == expected_result
'''

    def generate_integration_tests(self, module_name: str) -> Dict[str, str]:
        """生成集成测试 (20% - MySQL Docker)"""
        integration_tests = self._generate_integration_api_tests(module_name)
        
        return {
            f'tests/integration/test_{module_name}_integration.py': integration_tests
        }
    
    def _generate_integration_api_tests(self, module_name: str) -> str:
        """生成集成API测试 - MySQL Docker数据库"""
        return f'''"""
{module_name.title()} 集成测试套件

测试类型: 集成测试 (Integration)
数据策略: MySQL Docker, mysql_integration_db fixture  
生成时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

根据testing-standards.md第105-125行集成测试规范
"""

import pytest
import requests
from sqlalchemy.orm import Session

# 测试工厂导入
from tests.factories import {module_name.title()}Factory, UserFactory

# Fixture导入
from tests.conftest import mysql_integration_db, api_client

# 被测模块导入  
from app.modules.{module_name}.service import {module_name.title()}Service


@pytest.mark.integration
class Test{module_name.title()}Integration:
    """集成测试 - 真实环境模拟"""
    
    def setup_method(self):
        """集成测试准备"""
        self.api_base_url = "http://localhost:8000"
        self.test_data = {module_name.title()}Factory.build_dict()
        
    def test_{module_name}_api_integration(self, api_client, mysql_integration_db: Session):
        """测试{module_name} API完整集成"""
        # 创建API请求
        create_response = api_client.post(
            f"/{module_name}/",
            json=self.test_data
        )
        
        # 验证创建响应
        assert create_response.status_code == 201
        created_data = create_response.json()
        assert "id" in created_data
        {module_name}_id = created_data["id"]
        
        # 查询API验证
        get_response = api_client.get(f"/{module_name}/{{poll_id}}")
        assert get_response.status_code == 200
        
        # 更新API验证
        update_data = {{"status": "updated"}}
        update_response = api_client.put(
            f"/{module_name}/{{poll_id}}",
            json=update_data
        )
        assert update_response.status_code == 200
        
        # 删除API验证
        delete_response = api_client.delete(f"/{module_name}/{{poll_id}}")
        assert delete_response.status_code == 204
        
    def test_{module_name}_database_integration(self, mysql_integration_db: Session):
        """测试{module_name}数据库集成"""
        service = {module_name.title()}Service(mysql_integration_db)
        
        # 测试数据库事务完整性
        created = service.create(self.test_data)
        assert created is not None
        
        # 验证数据库持久化
        mysql_integration_db.commit()
        found = service.get_by_id(created.id)
        assert found is not None
        assert found.id == created.id
        
    def test_{module_name}_external_service_integration(self, mysql_integration_db: Session):
        """测试{module_name}外部服务集成"""
        service = {module_name.title()}Service(mysql_integration_db)
        
        # 模拟外部服务调用
        with pytest.raises((ConnectionError, TimeoutError), match="external"):
            # 这里应该是真实的外部服务调用测试
            pass
            
    @pytest.mark.slow
    def test_{module_name}_performance_integration(self, mysql_integration_db: Session):
        """测试{module_name}性能集成"""
        service = {module_name.title()}Service(mysql_integration_db)
        
        import time
        start_time = time.time()
        
        # 批量操作性能测试
        for i in range(100):
            test_data = {module_name.title()}Factory.build_dict()
            service.create(test_data)
            
        end_time = time.time()
        execution_time = end_time - start_time
        
        # 验证性能要求 (100个操作 < 5秒)
        assert execution_time < 5.0, f"Performance test failed: {{execution_time:.2f}}s > 5s"
'''

    def generate_smoke_tests(self, module_name: str) -> Dict[str, str]:
        """生成烟雾测试 (2% - SQLite文件)"""
        smoke_tests = self._generate_smoke_health_tests(module_name)
        
        return {
            f'tests/smoke/test_{module_name}_smoke.py': smoke_tests
        }
    
    def _generate_smoke_health_tests(self, module_name: str) -> str:
        """生成烟雾测试 - SQLite文件数据库"""
        return f'''"""
{module_name.title()} 烟雾测试套件

测试类型: 烟雾测试 (Smoke)
数据策略: SQLite文件数据库, smoke_test_db fixture
生成时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

根据testing-standards.md第95-104行烟雾测试规范
"""

import pytest
import requests
from sqlalchemy.orm import Session

# Fixture导入
from tests.conftest import smoke_test_db


@pytest.mark.smoke  
class Test{module_name.title()}Smoke:
    """烟雾测试 - 基本健康检查"""
    
    def test_{module_name}_health_check(self):
        """验证{module_name}模块基本健康状态"""
        try:
            # 模块导入测试
            from app.modules.{module_name} import service
            from app.modules.{module_name} import models
            assert True, "{module_name} module imports successfully"
        except ImportError as e:
            pytest.fail(f"{module_name} module import failed: {{e}}")
            
    def test_{module_name}_database_connection_smoke(self, smoke_test_db: Session):
        """验证{module_name}数据库连接正常"""
        # 简单的数据库连接测试
        result = smoke_test_db.execute("SELECT 1 as test")
        assert result.fetchone()[0] == 1
        
    def test_{module_name}_api_endpoint_smoke(self):
        """验证{module_name} API端点可访问性"""
        try:
            response = requests.get(
                "http://localhost:8000/{module_name}/health",
                timeout=5
            )
            assert response.status_code in [200, 404]  # 404也可接受，只要服务响应
        except requests.ConnectionError:
            pytest.skip("API服务未运行，跳过烟雾测试")
            
    def test_{module_name}_basic_functionality_smoke(self, smoke_test_db: Session):
        """验证{module_name}基本功能正常"""
        from app.modules.{module_name}.service import {module_name.title()}Service
        
        service = {module_name.title()}Service(smoke_test_db)
        
        # 最基本的功能测试
        basic_data = {{"name": "smoke_test", "status": "active"}}
        
        try:
            created = service.create(basic_data)
            assert created is not None
        except Exception as e:
            pytest.fail(f"{module_name} basic create functionality failed: {{e}}")
'''

    def generate_e2e_tests(self, module_name: str) -> Dict[str, str]:
        """生成E2E测试 (6% - MySQL Docker)"""
        e2e_tests = self._generate_e2e_workflow_tests(module_name)
        
        return {
            f'tests/e2e/test_{module_name}_e2e.py': e2e_tests
        }
    
    def _generate_e2e_workflow_tests(self, module_name: str) -> str:
        """生成E2E工作流测试 - MySQL Docker数据库"""
        return f'''"""
{module_name.title()} E2E测试套件

测试类型: 端到端测试 (E2E)
数据策略: MySQL Docker, mysql_e2e_db fixture
生成时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

根据testing-standards.md第135-155行E2E测试规范
"""

import pytest
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from sqlalchemy.orm import Session

# 测试工厂导入
from tests.factories import {module_name.title()}Factory, UserFactory

# Fixture导入
from tests.conftest import mysql_e2e_db, selenium_driver


@pytest.mark.e2e
@pytest.mark.slow
class Test{module_name.title()}E2E:
    """端到端测试 - 完整用户流程"""
    
    def setup_method(self):
        """E2E测试准备"""
        self.base_url = "http://localhost:3000"  # 前端应用URL
        self.test_user_data = UserFactory.build_dict()
        self.test_{module_name}_data = {module_name.title()}Factory.build_dict()
        
    def test_complete_{module_name}_user_journey(self, selenium_driver, mysql_e2e_db: Session):
        """测试{module_name}完整用户旅程"""
        driver = selenium_driver
        
        # 步骤1: 用户登录
        driver.get(f"{{self.base_url}}/login")
        
        # 输入登录信息
        username_field = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.ID, "username"))
        )
        password_field = driver.find_element(By.ID, "password")
        login_button = driver.find_element(By.ID, "login-btn")
        
        username_field.send_keys(self.test_user_data["username"])
        password_field.send_keys(self.test_user_data["password"])
        login_button.click()
        
        # 验证登录成功
        WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.ID, "dashboard"))
        )
        
        # 步骤2: 导航到{module_name}页面
        driver.get(f"{{self.base_url}}/{module_name}")
        
        # 步骤3: 创建新{module_name}
        create_button = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.ID, f"create-{module_name}-btn"))
        )
        create_button.click()
        
        # 填写表单
        name_field = driver.find_element(By.ID, f"{module_name}-name")
        name_field.send_keys(self.test_{module_name}_data["name"])
        
        submit_button = driver.find_element(By.ID, "submit-btn")
        submit_button.click()
        
        # 步骤4: 验证创建成功
        success_message = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.CLASS_NAME, "success-message"))
        )
        assert "successfully created" in success_message.text.lower()
        
        # 步骤5: 验证数据库中存在
        from app.modules.{module_name}.service import {module_name.title()}Service
        service = {module_name.title()}Service(mysql_e2e_db)
        
        created_items = service.get_all()
        assert len(created_items) > 0
        assert any(item.name == self.test_{module_name}_data["name"] for item in created_items)
        
    def test_{module_name}_error_handling_e2e(self, selenium_driver, mysql_e2e_db: Session):
        """测试{module_name}错误处理端到端流程"""
        driver = selenium_driver
        
        # 导航到{module_name}页面
        driver.get(f"{{self.base_url}}/{module_name}")
        
        # 尝试提交无效表单
        create_button = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.ID, f"create-{module_name}-btn"))
        )
        create_button.click()
        
        # 不填写必填字段，直接提交
        submit_button = driver.find_element(By.ID, "submit-btn")
        submit_button.click()
        
        # 验证错误消息显示
        error_message = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.CLASS_NAME, "error-message"))
        )
        assert "required" in error_message.text.lower()
'''

    def generate_specialized_tests(self, module_name: str) -> Dict[str, str]:
        """生成专项测试 (2% - 性能/安全)"""
        performance_tests = self._generate_performance_tests(module_name)
        security_tests = self._generate_security_tests(module_name)
        
        return {
            f'tests/performance/test_{module_name}_performance.py': performance_tests,
            f'tests/security/test_{module_name}_security.py': security_tests
        }
    
    def _generate_performance_tests(self, module_name: str) -> str:
        """生成性能测试"""
        return f'''"""
{module_name.title()} 性能测试套件

测试类型: 专项测试 (Performance)
生成时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

根据testing-standards.md第165-185行性能测试规范
"""

import pytest
import time
import threading
from concurrent.futures import ThreadPoolExecutor
from sqlalchemy.orm import Session

# 测试工厂导入
from tests.factories import {module_name.title()}Factory

# Fixture导入
from tests.conftest import mysql_integration_db

# 被测模块导入
from app.modules.{module_name}.service import {module_name.title()}Service


@pytest.mark.performance
@pytest.mark.slow
class Test{module_name.title()}Performance:
    """性能测试"""
    
    def test_{module_name}_create_performance(self, mysql_integration_db: Session):
        """测试{module_name}创建操作性能"""
        service = {module_name.title()}Service(mysql_integration_db)
        
        # 性能基准: 1000次创建操作 < 10秒
        start_time = time.time()
        
        for i in range(1000):
            test_data = {module_name.title()}Factory.build_dict()
            test_data['name'] = f"perf_test_{{i}}"
            service.create(test_data)
            
        end_time = time.time()
        execution_time = end_time - start_time
        
        assert execution_time < 10.0, f"Create performance failed: {{execution_time:.2f}}s > 10s"
        
    def test_{module_name}_query_performance(self, mysql_integration_db: Session):
        """测试{module_name}查询操作性能"""
        service = {module_name.title()}Service(mysql_integration_db)
        
        # 准备测试数据
        for i in range(100):
            test_data = {module_name.title()}Factory.build_dict()
            test_data['name'] = f"query_test_{{i}}"
            service.create(test_data)
            
        # 性能测试: 1000次查询 < 5秒
        start_time = time.time()
        
        for i in range(1000):
            results = service.get_all(limit=10)
            assert len(results) > 0
            
        end_time = time.time()
        execution_time = end_time - start_time
        
        assert execution_time < 5.0, f"Query performance failed: {{execution_time:.2f}}s > 5s"
        
    def test_{module_name}_concurrent_access(self, mysql_integration_db: Session):
        """测试{module_name}并发访问性能"""
        service = {module_name.title()}Service(mysql_integration_db)
        
        def create_item(thread_id):
            test_data = {module_name.title()}Factory.build_dict()
            test_data['name'] = f"concurrent_test_{{thread_id}}"
            return service.create(test_data)
            
        # 并发测试: 10个线程同时创建100个项目
        start_time = time.time()
        
        with ThreadPoolExecutor(max_workers=10) as executor:
            futures = [executor.submit(create_item, i) for i in range(100)]
            results = [f.result() for f in futures]
            
        end_time = time.time()
        execution_time = end_time - start_time
        
        # 验证所有操作成功
        assert all(r is not None for r in results)
        
        # 并发性能要求: 100个并发操作 < 15秒
        assert execution_time < 15.0, f"Concurrent performance failed: {{execution_time:.2f}}s > 15s"
'''
    
    def _generate_security_tests(self, module_name: str) -> str:
        """生成安全测试"""
        return f'''"""
{module_name.title()} 安全测试套件

测试类型: 专项测试 (Security)
生成时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

根据testing-standards.md第190-210行安全测试规范
"""

import pytest
import requests
from sqlalchemy.orm import Session

# 测试工厂导入
from tests.factories import {module_name.title()}Factory, UserFactory

# Fixture导入
from tests.conftest import mysql_integration_db, api_client


@pytest.mark.security
class Test{module_name.title()}Security:
    """安全测试"""
    
    def test_{module_name}_sql_injection_protection(self, api_client):
        """测试{module_name} SQL注入防护"""
        # SQL注入攻击测试
        malicious_payloads = [
            "'; DROP TABLE users; --",
            "1' OR '1'='1",
            "1; INSERT INTO users VALUES('hacker', 'password'); --"
        ]
        
        for payload in malicious_payloads:
            response = api_client.get(f"/{module_name}/{{payload}}")
            
            # 验证没有返回敏感数据或系统错误
            assert response.status_code in [400, 404, 422]
            assert "error" not in response.text.lower() or "sql" not in response.text.lower()
            
    def test_{module_name}_xss_protection(self, api_client):
        """测试{module_name} XSS防护"""
        xss_payloads = [
            "<script>alert('xss')</script>",
            "javascript:alert('xss')",
            "<img src=x onerror=alert('xss')>"
        ]
        
        for payload in xss_payloads:
            test_data = {module_name.title()}Factory.build_dict()
            test_data['name'] = payload
            
            response = api_client.post(f"/{module_name}/", json=test_data)
            
            if response.status_code == 201:
                # 如果创建成功，验证返回的数据已被转义
                response_text = response.text
                assert "<script>" not in response_text
                assert "javascript:" not in response_text
                
    def test_{module_name}_authorization_check(self, api_client):
        """测试{module_name}权限控制"""
        # 未授权访问测试
        response = api_client.get(f"/{module_name}/")
        
        # 根据实际权限设计验证
        if response.status_code == 401:
            assert "unauthorized" in response.text.lower()
        elif response.status_code == 403:
            assert "forbidden" in response.text.lower()
            
    def test_{module_name}_input_validation(self, api_client):
        """测试{module_name}输入验证"""
        # 无效输入测试
        invalid_payloads = [
            {{"name": ""}},  # 空值
            {{"name": "x" * 1000}},  # 超长值
            {{"invalid_field": "test"}},  # 无效字段
            {{}},  # 空对象
        ]
        
        for payload in invalid_payloads:
            response = api_client.post(f"/{module_name}/", json=payload)
            
            # 验证输入验证生效
            assert response.status_code in [400, 422]
            
    def test_{module_name}_rate_limiting(self, api_client):
        """测试{module_name}速率限制"""
        # 快速连续请求测试
        responses = []
        
        for i in range(100):  # 发送100个快速请求
            response = api_client.get(f"/{module_name}/")
            responses.append(response.status_code)
            
        # 验证是否有速率限制生效
        rate_limited = any(status == 429 for status in responses)
        
        # 如果没有速率限制，至少验证服务稳定性
        if not rate_limited:
            successful_requests = sum(1 for status in responses if status == 200)
            assert successful_requests > 50, "服务在高频请求下不稳定"
'''

    def generate_all_tests(self, module_name: str) -> Dict[str, str]:
        """生成完整的五层测试套件"""
        all_tests = {}
        
        # 70% 单元测试
        unit_tests = self.generate_unit_tests(module_name)
        all_tests.update(unit_tests)
        
        # 20% 集成测试  
        integration_tests = self.generate_integration_tests(module_name)
        all_tests.update(integration_tests)
        
        # 6% E2E测试
        e2e_tests = self.generate_e2e_tests(module_name)
        all_tests.update(e2e_tests)
        
        # 2% 烟雾测试
        smoke_tests = self.generate_smoke_tests(module_name)
        all_tests.update(smoke_tests)
        
        # 2% 专项测试
        specialized_tests = self.generate_specialized_tests(module_name)
        all_tests.update(specialized_tests)
        
        return all_tests
    
    def create_test_files(self, test_files: Dict[str, str]) -> None:
        """创建测试文件到磁盘"""
        for file_path, content in test_files.items():
            full_path = self.project_root / file_path
            
            # 确保目录存在
            full_path.parent.mkdir(parents=True, exist_ok=True)
            
            # 写入文件
            with open(full_path, 'w', encoding='utf-8') as f:
                f.write(content)
                
            print(f"✅ Created: {file_path}")
    
    def validate_module_exists(self, module_name: str) -> bool:
        """验证模块是否存在"""
        module_path = self.project_root / "app" / "modules" / module_name
        return module_path.exists()


class TestCodeValidator:
    """测试代码自动化验证器"""
    
    def __init__(self, project_root: Path):
        self.project_root = project_root
        self.validation_results = []
        
    def validate_generated_tests(self, test_files: Dict[str, str]) -> Dict[str, Any]:
        """验证生成的测试代码"""
        validation_report = {
            'total_files': len(test_files),
            'passed': 0,
            'failed': 0,
            'warnings': 0,
            'details': {}
        }
        
        for file_path, content in test_files.items():
            print(f"🔍 验证文件: {file_path}")
            
            file_validation = self._validate_single_file(file_path, content)
            validation_report['details'][file_path] = file_validation
            
            if file_validation['status'] == 'passed':
                validation_report['passed'] += 1
            elif file_validation['status'] == 'failed':
                validation_report['failed'] += 1
            else:
                validation_report['warnings'] += 1
                
        return validation_report
    
    def _validate_single_file(self, file_path: str, content: str) -> Dict[str, Any]:
        """验证单个测试文件"""
        validation = {
            'status': 'passed',
            'issues': [],
            'suggestions': [],
            'metrics': {}
        }
        
        # 1. 语法检查
        syntax_issues = self._check_syntax(content)
        if syntax_issues:
            validation['issues'].extend(syntax_issues)
            validation['status'] = 'failed'
            
        # 2. 导入验证
        import_issues = self._check_imports(content)
        if import_issues:
            validation['issues'].extend(import_issues)
            validation['status'] = 'failed'
            
        # 3. Factory Boy模式验证
        factory_issues = self._check_factory_pattern(content)
        if factory_issues:
            validation['suggestions'].extend(factory_issues)
            if validation['status'] == 'passed':
                validation['status'] = 'warning'
                
        # 4. pytest标准验证
        pytest_issues = self._check_pytest_standards(content)
        if pytest_issues:
            validation['suggestions'].extend(pytest_issues)
            
        # 5. 测试覆盖度分析
        validation['metrics'] = self._analyze_test_metrics(content)
        
        # 6. 文档字符串验证
        docstring_issues = self._check_docstrings(content)
        if docstring_issues:
            validation['suggestions'].extend(docstring_issues)
            
        return validation
    
    def _check_syntax(self, content: str) -> List[str]:
        """检查Python语法"""
        issues = []
        try:
            compile(content, '<generated_test>', 'exec')
        except SyntaxError as e:
            issues.append(f"语法错误 第{e.lineno}行: {e.msg}")
        except Exception as e:
            issues.append(f"编译错误: {str(e)}")
        return issues
    
    def _check_imports(self, content: str) -> List[str]:
        """检查导入语句"""
        issues = []
        lines = content.split('\n')
        
        required_imports = {
            'pytest': False,
            'Factory': False,
            'Session': False
        }
        
        for line in lines:
            line = line.strip()
            if line.startswith('import pytest'):
                required_imports['pytest'] = True
            if 'Factory' in line and 'from tests.factories' in line:
                required_imports['Factory'] = True  
            if 'Session' in line and 'sqlalchemy' in line:
                required_imports['Session'] = True
                
        for import_name, found in required_imports.items():
            if not found and import_name in content:
                issues.append(f"缺少必需导入: {import_name}")
                
        return issues
    
    def _check_factory_pattern(self, content: str) -> List[str]:
        """检查Factory Boy模式使用"""
        suggestions = []
        
        # 检查是否使用Factory.build()或Factory.create()
        if 'Factory' in content:
            if '.build()' not in content and '.create()' not in content:
                suggestions.append("建议使用Factory.build()或Factory.create()方法")
                
            if '.build_dict()' not in content and '.create_dict()' not in content:
                suggestions.append("建议使用Factory.build_dict()生成字典数据")
                
        return suggestions
    
    def _check_pytest_standards(self, content: str) -> List[str]:
        """检查pytest标准"""
        suggestions = []
        lines = content.split('\n')
        
        test_methods = [line for line in lines if 'def test_' in line]
        
        # 检查测试方法命名
        for line in test_methods:
            if 'def test_' in line:
                method_name = line.split('def ')[1].split('(')[0]
                if len(method_name) < 15:
                    suggestions.append(f"测试方法名过短，建议更具描述性: {method_name}")
                    
        # 检查断言语句
        assert_count = content.count('assert ')
        if assert_count < len(test_methods):
            suggestions.append("部分测试方法可能缺少断言语句")
            
        # 检查文档字符串
        docstring_count = content.count('"""')
        if docstring_count < len(test_methods) * 2:  # 每个方法至少应该有一个docstring
            suggestions.append("建议为所有测试方法添加文档字符串")
            
        return suggestions
    
    def _analyze_test_metrics(self, content: str) -> Dict[str, int]:
        """分析测试度量指标"""
        return {
            'test_methods': content.count('def test_'),
            'assert_statements': content.count('assert '),
            'mock_usage': content.count('Mock()') + content.count('mocker.'),
            'parametrized_tests': content.count('@pytest.mark.parametrize'),
            'fixtures_used': content.count('def test_') if 'fixture' in content else 0,
            'lines_of_code': len(content.split('\n'))
        }
    
    def _check_docstrings(self, content: str) -> List[str]:
        """检查文档字符串质量"""
        suggestions = []
        lines = content.split('\n')
        
        in_method = False
        method_has_docstring = False
        
        for i, line in enumerate(lines):
            if 'def test_' in line:
                in_method = True
                method_has_docstring = False
            elif in_method and '"""' in line:
                method_has_docstring = True
            elif in_method and (line.strip().startswith('def ') or i == len(lines) - 1):
                if not method_has_docstring:
                    method_name = lines[i-1].split('def ')[1].split('(')[0] if i > 0 else "unknown"
                    suggestions.append(f"方法缺少文档字符串: {method_name}")
                in_method = False
                
        return suggestions
    
    def print_validation_report(self, report: Dict[str, Any]) -> None:
        """打印验证报告"""
        print("\n" + "=" * 60)
        print("🔍 测试代码验证报告")
        print("=" * 60)
        
        print(f"📊 总体统计:")
        print(f"   • 总文件数: {report['total_files']}")
        print(f"   • 通过验证: {report['passed']} ✅")
        print(f"   • 验证失败: {report['failed']} ❌")  
        print(f"   • 警告提示: {report['warnings']} ⚠️")
        
        if report['failed'] > 0:
            print(f"\n❌ 验证失败的文件:")
            for file_path, details in report['details'].items():
                if details['status'] == 'failed':
                    print(f"   📁 {file_path}")
                    for issue in details['issues']:
                        print(f"      • {issue}")
                        
        if report['warnings'] > 0:
            print(f"\n⚠️  需要注意的文件:")
            for file_path, details in report['details'].items():
                if details['status'] == 'warning':
                    print(f"   📁 {file_path}")
                    for suggestion in details['suggestions']:
                        print(f"      • {suggestion}")
                        
        # 显示度量指标
        print(f"\n📈 代码度量指标:")
        total_metrics = {
            'test_methods': 0,
            'assert_statements': 0,
            'mock_usage': 0,
            'parametrized_tests': 0,
            'lines_of_code': 0
        }
        
        for details in report['details'].values():
            for key, value in details['metrics'].items():
                if key in total_metrics:
                    total_metrics[key] += value
                    
        print(f"   • 测试方法总数: {total_metrics['test_methods']}")
        print(f"   • 断言语句总数: {total_metrics['assert_statements']}")
        print(f"   • Mock使用次数: {total_metrics['mock_usage']}")
        print(f"   • 参数化测试: {total_metrics['parametrized_tests']}")
        print(f"   • 代码总行数: {total_metrics['lines_of_code']}")
        
        if total_metrics['test_methods'] > 0:
            avg_assertions = total_metrics['assert_statements'] / total_metrics['test_methods']
            print(f"   • 平均每测试断言数: {avg_assertions:.1f}")
            
        return report['failed'] == 0


def main():
    """主函数 - 命令行接口"""
    parser = argparse.ArgumentParser(
        description="五层架构标准测试生成器",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
示例用法:
  python scripts/generate_test_template.py user_auth --type all
  python scripts/generate_test_template.py shopping_cart --type unit  
  python scripts/generate_test_template.py inventory --type integration
  
测试类型说明:
  all          - 生成完整五层测试套件 (推荐)
  unit         - 仅生成单元测试 (70%)
  integration  - 仅生成集成测试 (20%)  
  e2e          - 仅生成E2E测试 (6%)
  smoke        - 仅生成烟雾测试 (2%)
  specialized  - 仅生成专项测试 (2%)
        """
    )
    
    parser.add_argument(
        "module_name",
        help="模块名称 (如: user_auth, shopping_cart)"
    )
    
    parser.add_argument(
        "--type", "-t",
        choices=["all", "unit", "integration", "e2e", "smoke", "specialized"],
        default="all",
        help="测试类型 (默认: all)"
    )
    
    parser.add_argument(
        "--validate", "-v",
        action="store_true",
        help="验证模块是否存在"
    )
    
    parser.add_argument(
        "--auto-validate",
        action="store_true",
        help="自动验证生成的测试代码质量"
    )
    
    parser.add_argument(
        "--skip-create",
        action="store_true", 
        help="仅生成代码但不创建文件（用于验证测试）"
    )
    
    args = parser.parse_args()
    
    # 创建生成器实例
    generator = FiveLayerTestGenerator()
    
    # 验证模块存在性
    if args.validate and not generator.validate_module_exists(args.module_name):
        print(f"❌ 模块 '{args.module_name}' 不存在于 app/modules/ 目录中")
        print(f"请先创建模块或检查模块名称拼写")
        return 1
    
    print(f"🚀 开始生成 {args.module_name} 模块的 {args.type} 测试...")
    print(f"📋 遵循标准: docs/standards/testing-standards.md")
    print("=" * 60)
    
    # 根据类型生成测试
    test_files = {}
    
    if args.type == "all":
        test_files = generator.generate_all_tests(args.module_name)
    elif args.type == "unit":
        test_files = generator.generate_unit_tests(args.module_name)
    elif args.type == "integration":
        test_files = generator.generate_integration_tests(args.module_name)
    elif args.type == "e2e":
        test_files = generator.generate_e2e_tests(args.module_name)
    elif args.type == "smoke":
        test_files = generator.generate_smoke_tests(args.module_name)
    elif args.type == "specialized":
        test_files = generator.generate_specialized_tests(args.module_name)
    
    # 自动验证生成的代码（如果启用）
    validation_passed = True
    if args.auto_validate:
        print("\n🔍 开始自动验证生成的测试代码...")
        validator = TestCodeValidator(generator.project_root)
        validation_report = validator.validate_generated_tests(test_files)
        validation_passed = validator.print_validation_report(validation_report)
        
        if not validation_passed:
            print("\n❌ 代码验证失败! 请检查上述问题后再创建文件。")
            if not args.skip_create:
                print("提示: 使用 --skip-create 参数仅生成代码进行验证而不创建文件")
                return 1
    
    # 创建测试文件（除非跳过）
    if not args.skip_create:
        generator.create_test_files(test_files)
        print("=" * 60)
        print(f"✅ 完成! 已生成 {len(test_files)} 个测试文件")
    else:
        print("=" * 60)
        print(f"✅ 代码生成完成! (--skip-create 模式，未创建文件)")
        
    print(f"📊 测试分布符合五层架构要求:")
    
    if args.type == "all":
        print("   • 70% 单元测试 (Mock + SQLite内存)")
        print("   • 20% 集成测试 (MySQL Docker)")  
        print("   • 6% E2E测试 (MySQL Docker)")
        print("   • 2% 烟雾测试 (SQLite文件)")
        print("   • 2% 专项测试 (性能/安全)")
    
    print(f"\n🧪 运行测试命令:")
    print(f"   pytest tests/unit/test_{args.module_name}_* -v")
    print(f"   pytest tests/integration/test_{args.module_name}_* -v")
    print(f"   pytest tests/smoke/test_{args.module_name}_* -v")
    
    return 0


if __name__ == "__main__":
    sys.exit(main())