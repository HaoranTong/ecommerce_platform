<#
.SYNOPSIS
Append a structured status entry to docs/status/status.md

.PARAMETER Message
Short summary of the status entry (required)
.PARAMETER Files
Comma-separated list of affected files or paths (optional)
.PARAMETER PrUrl
URL to related PR or issue (optional)
.PARAMETER Author
Author name to record (optional, defaults to 'automation')

Example:
.\scripts\log_status.ps1 -Message "Merged feature/product into dev" -Files "app/models.py, alembic/versions/0002_product.py" -PrUrl "https://github.com/.../pull/123" -Author "CI"
#>

Param(
    [Parameter(Mandatory = $true)] [string]$Message,
    [string]$Files = "",
    [string]$PrUrl = "",
    [string]$Author = "automation",
    [string]$Commit = "",
    [string]$Branch = "",
    [string]$Actor = ""
)

Set-StrictMode -Version Latest
$scriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path
$repo = Split-Path $scriptDir -Parent
Push-Location $repo
try {
    # --- 新架构：在独立的 status/logs 分支创建自动化日志文件 ---
    
    # remember current branch
    try {
        $current = git rev-parse --abbrev-ref HEAD 2>$null | Out-String
        $current = $current.Trim()
    }
    catch {
        $current = ''
    }

    $statusBranch = 'status/logs'
    # fetch latest remote branches first
    git fetch origin --prune | Out-Null

    # create or reset local status branch from remote if exists, otherwise create new
    $existsRemote = git ls-remote --heads origin $statusBranch | Select-String $statusBranch -Quiet
    if ($existsRemote) {
        git checkout -B $statusBranch origin/$statusBranch
    }
    else {
        # create new branch based on main (独立分支)
        git checkout -B $statusBranch origin/main 2>$null
    }

    # 在 status/logs 分支创建自动化日志文件
    $docsDir = Join-Path $repo 'docs\status'
    if (-not (Test-Path $docsDir)) { New-Item -ItemType Directory -Path $docsDir -Force | Out-Null }
    
    $automationLogFile = Join-Path $docsDir 'automation_logs.md'
    if (-not (Test-Path $automationLogFile)) {
        $header = @"
# Automation Logs

This file contains automated logs from release and deployment scripts.
**Do not edit manually** - this file is managed by automation scripts.

Generated by: release_to_main.ps1, log_status.ps1
Last updated: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')

---

"@
        Set-Content -Path $automationLogFile -Value $header -Encoding UTF8
    }

    # 添加自动化日志条目
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $commitHash = git rev-parse HEAD 2>$null
    $logEntry = @"

## $timestamp - $Branch
**Action:** $Message  
**Branch:** $Branch  
**Commit:** $commitHash  
**Author:** $Author  
$(if ($Files -ne "") { "**Files:** $Files`n" })$(if ($PrUrl -ne "") { "**PR/Issue:** $PrUrl`n" })$(if ($Actor -ne "") { "**Actor:** $Actor`n" })
---

"@
    
    Add-Content -Path $automationLogFile -Value $logEntry -Encoding UTF8
    Write-Output "Appended automation log entry to $automationLogFile (on $statusBranch branch)"

    # 提交到独立的日志分支
    git add $automationLogFile
    $commitMsg = "automation: $Message ($(Get-Date -Format o))"
    git commit -m $commitMsg
    if ($LASTEXITCODE -ne 0) {
        Write-Output "No changes to commit on $statusBranch"
    }
    
    # Push with timeout and error handling to both remotes
    Write-Output "Pushing automation logs to GitHub and Gitee..."
    
    # Push to GitHub
    Write-Output "Pushing to GitHub..."
    $pushJob = Start-Job -ScriptBlock { git push github $using:statusBranch 2>&1 }
    if (Wait-Job $pushJob -Timeout 30) {
        $pushResult = Receive-Job $pushJob
        Write-Output "GitHub: $pushResult"
    } else {
        Stop-Job $pushJob
        Remove-Job $pushJob
        Write-Warning "GitHub push operation timed out after 30 seconds"
    }
    Remove-Job $pushJob -Force -ErrorAction SilentlyContinue
    
    # Push to Gitee
    Write-Output "Pushing to Gitee..."
    $pushJob = Start-Job -ScriptBlock { git push gitee $using:statusBranch 2>&1 }
    if (Wait-Job $pushJob -Timeout 30) {
        $pushResult = Receive-Job $pushJob
        Write-Output "Gitee: $pushResult"
    } else {
        Stop-Job $pushJob
        Remove-Job $pushJob
        Write-Warning "Gitee push operation timed out after 30 seconds"
    }
    Remove-Job $pushJob -Force -ErrorAction SilentlyContinue

    # return to previous branch if possible
    if ($current -and $current -ne $statusBranch) { 
        git checkout $current 
        Write-Output "Returned to branch: $current"
    }
}
finally {
    Pop-Location
}

